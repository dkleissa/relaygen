package main

import "text/template"

const node = `// Automatically generated by github.com/sebach1/gqlgen-relay
// DO NOT EDIT

package {{.Pkg}}


// {{.Name}}Edge is the edge representation of {{.Name}}
type {{.Name}}Edge struct {
	Cursor string ` + "`{{.Marshal}}:\"cursor\"`" + `
	Node   {{.Type}}   ` + "`{{.Marshal}}:\"{{.Name}}\"`" + `
}

// {{.Name}}Connection is the connection containing edges of {{.Name}}
type {{.Name}}Connection struct {
	Edges      []*{{.Name}}Edge   ` + "`{{.Marshal}}:\"node\"`" + `
	PageInfo   relay.PageInfo  ` + "`{{.Marshal}}:\"pageInfo\"`" + `
	TotalCount *int           ` + "`{{.Marshal}}:\"totalCount\"`" + `
}

type {{.Name}}PaginationFunc = func(offset, limit int) (items []{{.Type}}, total *int, err error)

// New{{.Name}}Page creates a new page from a pagination func of {{.Name}}
func New{{.Name}}Page(limit int, first *int, afterCursor *string, beforeCursor *string, paginate {{.Name}}PaginationFunc) (
*{{.Name}}Connection, error) {
	var decoded bool
	var offset int
	var err error

	if first != nil {
		limit = *first
	}

	if afterCursor != nil {
		out, err := DecodeCursor(*afterCursor)
		if err != nil {
			return nil, err
		}
		offset = out.Offset + 1
		decoded = true
	} 

	if !decoded && beforeCursor != nil {
		out, err := DecodeCursor(*beforeCursor)
		if err != nil {
			return nil, err
		}
		offset = out.Offset - limit
		decoded = true 
	}

	if !decoded{
		return nil, errPagination
	}

	items, total, err := paginate(offset, limit)
	if err != nil {
		return nil, err
	}

	var page *{{.Name}}Connection
	var i int

	for i, item := range items {
		page.Edges = append(page.Edges, &{{.Name}}Edge{
			Cursor: EncodeCursor(NewCursor(offset+i, item.ID)),
			Node:   item,
		})
	}
	edgesSz := i+1

	var startCursor, endCursor *string
	if edgesSz > 0 {
		startCursor = relay.NewString(page.Edges[0].Cursor)
		endCursor = relay.NewString(page.Edges[i].Cursor)
	}

	hasNextPage := false
	hasPreviousPage := offset > 0

	if total != nil {
		if afterCursor == nil {
			*total -= 1
		}
		hasNextPage = (offset + edgesSz) < *total
	}

	page.PageInfo = relay.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     startCursor,
		EndCursor:       endCursor,
	}

	page.TotalCount = total

	return page, nil
}
`

var nodeTemplate = template.Must(template.New("node").Parse(node))

const cursor = `
// Cursor is the main pagination actor 
type Cursor struct {
	Offset int   ` + "`{{.Marshal}}:\"offset\"`" + `
	ID     string  ` + "`{{.Marshal}}:\"id\"`" + `
}

// NewCursor creates a new cursor given an offset and an id
func NewCursor(offset int, id fmt.Stringer) *Cursor {
	return &Cursor{Offset: offset, ID: id.String()}
}

// EncodeCursor encodes a Cursor struct onto a string
func EncodeCursor(cursor *Cursor) string {
	b, err := msgpack.Marshal(cursor)
	if err != nil {
		panic("unable to marshal cursor: " + err.Error())
	}
	return base64.StdEncoding.EncodeToString(b)
}

// DecodeCursor decodes a cursor (string) into a Cursor struct
func DecodeCursor(encCursor string) (decCursor *Cursor, err error) {
	stdDecCursor, err := base64.StdEncoding.DecodeString(encCursor)
	if err != nil {
		return nil, errors.Wrap(err, "unable to decode cursor")
	}

	err = errors.Wrap(msgpack.Unmarshal(stdDecCursor, decCursor), "unable to unmarshal cursor")
	if err != nil {
		return nil, err
	}
	
	return decCursor, err
}

func MustDecodeCursor(encCursor string) *Cursor {
	decCursor, err := DecodeCursor(encCursor)
	if err != nil {
		panic("unable to decode cursor: " + err.Error())
	}
	return decCursor
}

var errPagination = errors.New("invalid pagination parameters")
`

var cursorTemplate = template.Must(template.New("cursor").Parse(cursor))
